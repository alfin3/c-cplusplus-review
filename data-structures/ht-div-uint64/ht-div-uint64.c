/**
   ht-div-uint64.c

   A hash table with generic hash keys and generic elements. The 
   implementation is based on a division method for hashing into upto  
   > 2^63 slots (last entry in the primes array; the upper range requiring 
   > 2^64 addresses) and a chaining method for resolving collisions.
   
   The load factor of a hash table is the expected number of keys in a slot 
   under the simple uniform hashing assumption, and is upper-bounded by the 
   alpha parameter. The alpha parameter does not provide an upper bound 
   after the maximum size of a hash table is reached.

   A hash key is an object within a continuous block of memory (e.g. a basic 
   type, array, struct). 

   An element is an object within a continuous block of memory (e.g. a basic 
   type, array, struct), or a multilayered object in memory.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include "ht-div-uint64.h"
#include "dll.h"
#include "utilities-rand-mod.h"

static uint64_t hash(ht_div_uint64_t *ht, void *key);
static void ht_grow(ht_div_uint64_t *ht);
static void copy_reinsert(ht_div_uint64_t *ht, dll_node_t *node);

/**
   An array of primes in the increasing order, approximately doubling in 
   magnitude, that are not too close to the powers of 2 and 10 to avoid 
   hashing regularities due to the structure of data. The prime numbers
   were generated by applying miller-rabin-uint64.
*/
static const uint64_t primes[54] = {1543, 3119,
				    6211, 12343,
				    23981, 48673,
				    88843, 186581,
				    377369, 786551,
				    1483331, 3219497,
				    6278177, 12538919,
				    25166719, 51331771,
				    112663669, 211326637,
				    412653239, 785367311,
				    1611612763, 3221225479,
				    6442451311, 12881269573,
				    25542415651, 51713873269,
				    119353582331, 211752305939,
				    417969972941, 817459404833,
				    1621224516137, 3253374675631,
				    6594291673951, 13349461912351,
				    26380589320219, 52758518323127,
				    118691918825723, 214182177768131,
				    419189283369523, 832735214133421,
				    1672538661088171, 3158576518771277,
				    6692396525189279, 13791536538127669,
				    26532115188884581, 55793289756397591,
				    113545326073368661, 217449629757435791,
				    431794910914467367, 841413987972987841,
				    1755714234418853843, 3358355678469146183,
				    6884922145916737697, 15769474759331449193U};
static const int num_uint32_primes = 22;
static const int num_primes = 54;

/**
   Initializes a hash table. 
   ht: a pointer to a previously created ht_div_uint64_t instance.
   alpha: > 0.0, a load factor upper bound.
   cmp_key_fn: 0 iff two keys are equal.
   free_elt_fn: - if an element is of a basic type or is an array or struct 
                within a continuous memory block, as reflected by elt_size, 
                and a pointer to the element is passed as elt in 
                ht_div_uint64_insert, then the element is fully copied into 
                a block pointed from a node of the dll at the slot index 
                computed by a hash function, and a NULL as free_elt_fn is 
                sufficient to delete the element;
                - if an element is multilayered, and a pointer to a pointer
                to the element is passed as elt in ht_div_uint64_insert, then
                the pointer to the element is copied into a block pointed 
                from a node of the dll at the slot index computed by a hash 
                function, and an element-specific free_elt_fn is necessary 
                to delete the element.
*/
void ht_div_uint64_init(ht_div_uint64_t *ht,
                        int key_size,
	                int elt_size,
			float alpha,
                        int (*cmp_key_fn)(void *, void *),
	                void (*free_elt_fn)(void *)){
  ht->ht_size_ix = 0;
  ht->key_size = key_size;
  ht->elt_size = elt_size;
  ht->ht_size = primes[ht->ht_size_ix];
  ht->num_elts = 0;
  ht->alpha = alpha;
  ht->key_elts = malloc(ht->ht_size * sizeof(dll_node_t *));
  assert(ht->key_elts != NULL);
  for (uint64_t i = 0; i < ht->ht_size; i++){
    dll_init(&(ht->key_elts[i]));
  }
  ht->cmp_key_fn = cmp_key_fn;
  ht->free_elt_fn = free_elt_fn;
}

/**
   Inserts a key and an associated element into a hash table. If the key is
   in the hash table, associates the key with the new element. The key and 
   elt parameters are not NULL.
*/
void ht_div_uint64_insert(ht_div_uint64_t *ht, void *key, void *elt){
  //grow ht if E[# keys in a slot] > alpha
  while ((float)(ht->num_elts) / ht->ht_size > ht->alpha &&
	 ht->ht_size_ix < num_primes - 1){
    ht_grow(ht);
  }
  uint64_t ix = hash(ht, key);
  dll_node_t **head = &(ht->key_elts[ix]);
  dll_node_t *node = dll_search_key(head, key, ht->cmp_key_fn);
  if (node == NULL){
    dll_insert(head, key, elt, ht->key_size, ht->elt_size);
    ht->num_elts++;
  }else{
    dll_delete(head, node, ht->free_elt_fn);
    dll_insert(head, key, elt, ht->key_size, ht->elt_size);
  }   
}

/**
   If a key is present in a hash table, returns a pointer to its associated 
   element, otherwise returns NULL. The key parameter is not NULL.
*/
void *ht_div_uint64_search(ht_div_uint64_t *ht, void *key){
  uint64_t ix = hash(ht, key);
  dll_node_t **head = &(ht->key_elts[ix]);
  dll_node_t *node = dll_search_key(head, key, ht->cmp_key_fn);
  if (node == NULL){
    return NULL;
  }else{
    return node->elt;
  }
}

/**
   Removes a key and the associated element from a hash table by copying 
   the element into a block of size elt_size pointed to by elt. If the key is
   not in the hash table, leaves the block pointed to by elt unchanged.
   The key and elt parameters are not NULL.
*/
void ht_div_uint64_remove(ht_div_uint64_t *ht, void *key, void *elt){
  uint64_t ix = hash(ht, key);
  dll_node_t **head = &(ht->key_elts[ix]);
  dll_node_t *node = dll_search_key(head, key, ht->cmp_key_fn);
  if (node != NULL){
    memcpy(elt, node->elt, ht->elt_size);
    //NULL: if an element is multilayered, only the pointer to it is deleted
    dll_delete(head, node, NULL);
    ht->num_elts--;
  }
}

/**
   If a key is present in a hash table, deletes the key and its associated 
   element according free_elt_fn. The key parameter is not NULL.
*/
void ht_div_uint64_delete(ht_div_uint64_t *ht, void *key){
  uint64_t ix = hash(ht, key);
  dll_node_t **head = &(ht->key_elts[ix]);
  dll_node_t *node = dll_search_key(head, key, ht->cmp_key_fn);
  if (node != NULL){
    dll_delete(head, node, ht->free_elt_fn);
    ht->num_elts--;
  }
}

/**
   Frees a hash table and leaves a block of size sizeof(ht_div_uint64_t)
   pointed to by the ht parameter.
*/
void ht_div_uint64_free(ht_div_uint64_t *ht){
  for (uint64_t i = 0; i < ht->ht_size; i++){
    dll_free(&(ht->key_elts[i]), ht->free_elt_fn);
  }
  free(ht->key_elts);
  ht->key_elts = NULL;
}

/** Helper functions */

/**
   Maps a hash key to a slot index in a hash table with a division method. 
   The hash key is an object of size key_size within a continuous block of 
   memory pointed to by key.
*/
static uint64_t hash(ht_div_uint64_t *ht, void *key){
  if (ht->ht_size_ix < num_uint32_primes){
    //fast_mem_mod_uint32 is faster than fast_mem_mod_uint64
    return (uint64_t)fast_mem_mod_uint32(key,
					 (uint64_t)ht->key_size,
					 (uint32_t)ht->ht_size);
  }else{
    return fast_mem_mod_uint64(key,
			       (uint64_t)ht->key_size,
			       ht->ht_size);
  } 
}

/**
   Increases the size of a hash table by the difference between the ith and 
   (i + 1)th prime numbers in the primes array. Makes no changes if the last
   prime number in the primes array was reached.
*/
static void ht_grow(ht_div_uint64_t *ht){
  //if the largest size is reached, alpha is not a bound for expectation
  if (ht->ht_size_ix == num_primes - 1){return;}
  uint64_t prev_ht_size = ht->ht_size;
  dll_node_t **prev_key_elts = ht->key_elts;
  dll_node_t **head;
  ht->ht_size_ix++;
  ht->ht_size = primes[ht->ht_size_ix];
  ht->num_elts = 0;
  ht->key_elts = malloc(ht->ht_size * sizeof(dll_node_t *));
  assert(ht->key_elts != NULL);
  for (uint64_t i = 0; i < ht->ht_size; i++){
    head = &(ht->key_elts[i]);
    dll_init(head);
  }
  for (uint64_t i = 0; i < prev_ht_size; i++){
    head = &(prev_key_elts[i]);
    while (*head != NULL){
      copy_reinsert(ht, *head);
      //NULL:if an element is multilayered, only the pointer to it is deleted
      dll_delete(head, *head, NULL);
    }
  }
  free(prev_key_elts);
  prev_key_elts = NULL;
  head = NULL;
}

/**
   Reinserts a copy of a node into a new hash table during an ht_grow 
   operation. In contrast to ht_div_uint64_insert, no search is performed.
*/
static void copy_reinsert(ht_div_uint64_t *ht, dll_node_t *node){
  uint64_t ix = hash(ht, node->key);
  dll_node_t **head = &(ht->key_elts[ix]);
  dll_insert(head, node->key, node->elt, ht->key_size, ht->elt_size);
  ht->num_elts++;   
}
